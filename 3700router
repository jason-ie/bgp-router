#!/usr/bin/env python3

import argparse
import json
import socket
import select
import ipaddress

class BGP_Router:
    def __init__(self, asn, connections):
        self.asn = asn
        self.connections = {}
        self.forwarding_table = []
        self.initialize_connections(connections)

    def initialize_connections(self, connections):
        for conn_str in connections:
            port, ip, relation = conn_str.split('-')
            self.connections[ip] = {
                'port': int(port),
                'relation': relation,
                'socket': self.create_socket_and_bind()
            }
            self.send_handshake(ip)

    def create_socket_and_bind(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('localhost', 0))
        return sock

    def send_handshake(self, ip):
        handshake_msg = {
            "type": "handshake",
            "src": self.asn,
            "dst": ip,
            "msg": {}
        }
        self.send_message(ip, handshake_msg)

    def send_message(self, ip, message):
        conn_info = self.connections[ip]
        sock = conn_info['socket']
        port = conn_info['port']
        sock.sendto(json.dumps(message).encode(), ('localhost', port))

    def handle_message(self, message):
        if message['type'] == 'update':
            self.handle_update(message)
        elif message['type'] == 'data':
            self.handle_data(message)
        elif message['type'] == 'dump':
            self.handle_dump(message)
        elif message['type'] == 'withdraw':
            self.handle_withdraw(message)
        else:
            print(f"Unhandled message type: {message['type']}")

    def send_update_to_peers(self, update_message, source_ip):
            # Implement BGP propagation rules here
            source_relation = self.connections[source_ip]['relation']
            for ip, info in self.connections.items():
                if ip != source_ip:
                    if source_relation == 'cust' or (source_relation in ['peer', 'prov'] and info['relation'] == 'cust'):
                        self.send_message(ip, update_message)

    def handle_update(self, message):
        src = message['src']
        msg = message['msg']
        if self.asn in msg['ASPath']:
            return  # Avoid routing loops
        
        # Update ASPath to include this router's ASN
        msg['ASPath'].append(self.asn)
        
        self.update_forwarding_table(src, msg)
        self.propagate_update(msg, src)

    def update_forwarding_table(self, src, msg):
        new_route = {
            'network': msg['network'],
            'netmask': msg['netmask'],
            'ASPath': msg['ASPath'],  # Already appended this ASN in handle_update
            'next_hop': src,  # Use the message source as the next hop
            'origin': msg.get('origin', 'IGP'),
            'localpref': msg.get('localpref', 100),
        }
        
        # Find and replace or append new route
        for i, route in enumerate(self.forwarding_table):
            if route['network'] == new_route['network'] and route['netmask'] == new_route['netmask']:
                if len(new_route['ASPath']) < len(route['ASPath']) or new_route['localpref'] > route['localpref']:
                    self.forwarding_table[i] = new_route
                    return
                break
        else:
            self.forwarding_table.append(new_route)

    def propagate_update(self, msg, src):
        for peer_ip, info in self.connections.items():
            # Do not send back to the source or propagate inappropriately according to BGP rules
            if peer_ip == src or (info['relation'] != 'cust' and self.connections[src]['relation'] != 'cust'):
                continue
            
            # Prepare a new message for propagation
            propagated_msg = {
                'type': 'update',
                'src': self.asn,
                'dst': peer_ip,
                'msg': {
                    'network': msg['network'],
                    'netmask': msg['netmask'],
                    'ASPath': msg['ASPath'],  # Do not append ASN here; it's already done
                    'next_hop': msg.get('next_hop', src),  # Use original next_hop if provided
                    'origin': msg['origin'],
                    'localpref': msg.get('localpref', 100),
                }
            }
            self.send_message(peer_ip, propagated_msg)


    def handle_data(self, message):
            dst_ip_str = message['msg'].get('dst')
            if not dst_ip_str:
                print("Data message missing 'dst'.")
                return

            dst_ip = ipaddress.ip_address(dst_ip_str)
            best_route = self.find_best_route(dst_ip)
            if best_route:
                self.send_message(best_route['next_hop'], message)
            else:
                print(f"No route found for {dst_ip_str}")

    def find_best_route(self, dst_ip):
        best_route = None
        for route in self.forwarding_table:
            if dst_ip in ipaddress.ip_network(f"{route['network']}/{route['netmask']}"):
                if not best_route or len(route['ASPath']) < len(best_route['ASPath']):
                    best_route = route
        return best_route

    def handle_dump(self, message):
        table_msg = {
            "type": "table",
            "src": self.asn,
            "dst": message['src'],
            "msg": self.forwarding_table
        }
        self.send_message(message['src'], table_msg)

    def run(self):
        while True:
            readable_sockets = [conn['socket'] for conn in self.connections.values()]
            readable, _, _ = select.select(readable_sockets, [], [], 1)
            for sock in readable:
                data, _ = sock.recvfrom(4096)
                message = json.loads(data.decode())
                self.handle_message(message)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Simplified BGP Router")
    parser.add_argument("asn", type=int, help="Autonomous System Number")
    parser.add_argument("connections", nargs='+', help="Peer connections in 'port-ip-relation' format")
    args = parser.parse_args()

    bgp_router = BGP_Router(args.asn, args.connections)
    bgp_router.run()

