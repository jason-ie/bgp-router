#!/usr/bin/env python3

import argparse
import json
import socket
import select
import ipaddress

class BGP_Router:
    def __init__(self, asn, connections):
        self.asn = asn
        self.connections = {}
        self.forwarding_table = []
        self.initialize_connections(connections)

    def initialize_connections(self, connections):
        for conn_str in connections:
            port, ip, relation = conn_str.split('-')
            self.connections[ip] = {
                'port': int(port),
                'relation': relation,
                'socket': self.create_socket_and_bind()
            }
            self.send_handshake(ip)

    def create_socket_and_bind(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('localhost', 0))
        return sock

    def send_handshake(self, ip):
        handshake_msg = {
            "type": "handshake",
            "src": self.asn,
            "dst": ip,
            "msg": {}
        }
        self.send_message(ip, handshake_msg)

    def send_message(self, ip, message):
        conn_info = self.connections[ip]
        sock = conn_info['socket']
        port = conn_info['port']
        sock.sendto(json.dumps(message).encode(), ('localhost', port))

    def handle_message(self, message):
        if message['type'] == 'update':
            self.handle_update(message)
        elif message['type'] == 'data':
            self.handle_data(message)
        elif message['type'] == 'dump':
            self.handle_dump(message)
        elif message['type'] == 'withdraw':
            self.handle_withdraw(message)
        else:
            print(f"Unhandled message type: {message['type']}")

    def send_update_to_peers(self, message, src):
        for peer_ip, info in self.connections.items():
            if peer_ip != src:  # Don't send the update back to the source
                print(f"Sending update to {peer_ip}: {message}")  # Debug output
                self.send_message(peer_ip, message)

    def handle_update(self, message):
        src = message['src']
        msg = message['msg']

        # Check if the update source is a customer, peer, or provider
        relation = self.connections[src]['relation']

        # Update received from a customer: send updates to all other neighbors
        # Update received from a peer or a provider: only send updates to your customers
        if relation == 'cust':
            self.send_update_to_peers(message, src)
        elif relation in ('peer', 'prov'):
            for peer_ip, peer_info in self.connections.items():
                if peer_info['relation'] == 'cust':
                    self.send_message(peer_ip, {
                        'type': 'update',
                        'src': self.asn,
                        'dst': peer_ip,
                        'msg': {
                            'network': msg['network'],
                            'netmask': msg['netmask'],
                            'ASPath': msg['ASPath'] + [self.asn],
                            'next_hop': msg.get('next_hop', src),
                        }
                    })

        # Rest of your existing update handling logic...

    def handle_withdraw(self, message):
        src = message['src']
        msg = message['msg']

        for route in self.forwarding_table:
            if route['network'] == msg['network'] and route['netmask'] == msg['netmask']:
                self.forwarding_table.remove(route)
                break

        self.send_update_to_peers(message, src)

    def handle_data(self, message):
        dst_ip_str = message['msg'].get('dst')
        if not dst_ip_str:
            print("Data message missing 'dst'.")
            return

        dst_ip = ipaddress.ip_address(dst_ip_str)
        best_route = self.find_best_route(dst_ip)
        if best_route:
            self.send_message(best_route['next_hop'], message)
        else:
            print(f"No route found for {dst_ip_str}")

    def find_best_route(self, dst_ip):
        best_route = None
        for route in self.forwarding_table:
            if dst_ip in ipaddress.ip_network(f"{route['network']}/{route['netmask']}"):
                if not best_route or len(route['ASPath']) < len(best_route['ASPath']):
                    best_route = route
        return best_route

    def handle_dump(self, message):
        table_msg = {
            "type": "table",
            "src": self.asn,
            "dst": message['src'],
            "msg": self.forwarding_table
        }
        self.send_message(message['src'], table_msg)

    def run(self):
        while True:
            readable_sockets = [conn['socket'] for conn in self.connections.values()]
            readable, _, _ = select.select(readable_sockets, [], [], 1)
            for sock in readable:
                data, _ = sock.recvfrom(4096)
                message = json.loads(data.decode())
                self.handle_message(message)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Simplified BGP Router")
    parser.add_argument("asn", type=int, help="Autonomous System Number")
    parser.add_argument("connections", nargs='+', help="Peer connections in 'port-ip-relation' format")
    args = parser.parse_args()

    bgp_router = BGP_Router(args.asn, args.connections)
    bgp_router.run()
