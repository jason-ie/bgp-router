#!/usr/bin/env -S python3 -u

import argparse, socket, json, select
# Importing necessary libraries. argparse for command line arguments, socket for network connections,
# time for time-related tasks, json for JSON parsing, select for handling multiple sockets at once,
# struct for packing data, sys for system-specific parameters, math for mathematical operations, and copy for copying data structures.

class Router:
    relations = {}
    sockets = {}
    ports = {}
    routing_table  = {}
    # Defining class variables. relations, sockets, and ports are dictionaries that will hold the relationships, sockets, and ports for each neighbor.
    # routing_table is a list that will hold the routing information.

    def __init__(self, asn, connections):
        """
        The constructor for the Router class. It initializes the router with its Autonomous System Number (ASN) and its connections.

        Parameters:
        asn (int): The Autonomous System Number of the router.
        connections (list): A list of connections for the router. Each connection is a string in the format "port-neighbor-relation".
        """
        print("Router at AS %s starting up" % asn)
        # Print a startup message.
        self.asn = asn
        # Set the ASN for this router.
        self.networks = connections
        for relationship in connections:
            # For each connection in the connections list...
            port, neighbor, relation = relationship.split("-")
            # Split the relationship string into port, neighbor, and relation.
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            # Create a new UDP socket for the neighbor.
            self.sockets[neighbor].bind(('localhost', 0))
            # Bind the socket to the localhost on a random free port.
            self.ports[neighbor] = int(port)
            # Store the port number for the neighbor.
            self.relations[neighbor] = relation
            # Store the relation for the neighbor.
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            # Send a handshake message to the neighbor.

    def our_addr(self, dst):
        """
        This function takes a destination IP address and returns the source IP address for this router.

        Parameters:
        dst (str): The destination IP address.

        Returns:
        str: The source IP address for this router.
        """
        # This function takes a destination IP address and returns the source IP address for this router.
        quads = list(int(qdn) for qdn in dst.split('.'))
        # Split the destination IP address into its four quads.
        quads[3] = 1
        # Set the last quad to 1.
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])
        # Return the source IP address.

    def send(self, network, message):
        """
        This function sends a message to a network.

        Parameters:
        network (str): The network to which the message should be sent.
        message (str): The message to send.
        """
        # This function sends a message to a network.
        port = self.ports[network]
        # Get the port for the network.
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', port))
        # Send the message to the network.

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                print("Received message '%s' from %s" % (msg, srcif))
                self.handle_message(json.loads(msg))

    def handle_message(self, message):
        """
        This function handles a message based on its type.

        Parameters:
        message (dict): The message to handle. The message should be a dictionary with a "type" key.
        """
        # This function handles a message.
        msg_type = message["type"]
        # Get the type of the message.
        if msg_type == "update":
            # If the message is an update...
            self.handle_update(message)
            # Handle the update.
        elif msg_type == "handshake":
            # If the message is a handshake...
            self.handle_handshake(message)
            # Handle the handshake.
        elif msg_type == "dump":
            # If the message is a dump...
            self.handle_dump(message)
            # Handle the dump.
        elif msg_type == "data":
            # If the message is data...
            self.handle_data(message)
            # Handle the data.
        else:
            # If the message type is unknown...
            print(f"Unhandled message type: {msg_type}")
            # Print an error message.
            
    def ip_to_bin(self, ip):
        """
        This function converts an IP address to binary.

        Parameters:
        ip (str): The IP address to convert.

        Returns:
        str: The binary representation of the IP address.
        """
        return ''.join([bin(int(x) + 256)[3:] for x in ip.split('.')])

    def handle_update(self, message):
        """
        This function handles an update message.

        Parameters:
        message (dict): The update message to handle.
        """
        network = message["msg"]["network"]
        netmask = message["msg"]["netmask"]
        localpref = message["msg"]["localpref"]
        as_path = message["msg"]["ASPath"]
        origin = message["msg"]["origin"]
        selfOrigin = message["msg"].get("selfOrigin", False)
        route_key = f"{network}/{netmask}"
        self.routing_table[route_key] = {
            "src": message["src"],
            "dst": message["dst"],
            "localpref": localpref,
            "ASPath": as_path,
            "origin": origin,
            "selfOrigin": selfOrigin,
            "received_from": message["src"]
        }
        self.propagate_update(message)


    def propagate_update(self, msg):
        """
        This function propagates an update message to all neighbors except the one from which the original message was received.

        Parameters:
        msg (dict): The original update message.
        """
        for neighbor, info in self.sockets.items():
            if neighbor != msg["src"]:
                updated_message = {
                    "type": "update",
                    "src": self.our_addr(neighbor),
                    "dst": neighbor,
                    "msg": {
                        "network": msg["msg"]["network"],
                        "netmask": msg["msg"]["netmask"],
                        "ASPath": [self.asn] + msg["msg"]["ASPath"],
                    }
                }
                self.send(neighbor, json.dumps(updated_message))

    def handle_handshake(self, src, msg):
        print("Handshake received from %s" % src)

    def handle_dump(self, message):
        """
        This function handles a dump message.

        Parameters:
        message (dict): The dump message to handle.
        """
        table_message = {
            "src": message["dst"],
            "dst": message["src"],
            "type": "table",
            "msg": []
        }
        for route_key, route_info in self.routing_table.items():
            table_message["msg"].append({
                "network": route_key.split('/')[0],
                "netmask": route_key.split('/')[1],
                "peer": route_info["received_from"],
                "localpref": route_info["localpref"],
                "ASPath": route_info["ASPath"],
                "selfOrigin": route_info["selfOrigin"],
                "origin": route_info["origin"]
            })
        self.send(message["src"], json.dumps(table_message))

    def find_best_route(self, dst_ip):
        """
        This function finds the best route for a given destination IP address.

        Parameters:
        dst_ip (str): The destination IP address.

        Returns:
        dict: The best route for the destination IP address.
        """
        dst_ip_bin = int(self.ip_to_bin(dst_ip), 2)

        for route_key, route_desc in self.routing_table.items():
            network, netmask = route_key.split('/')
            network_bin = int(self.ip_to_bin(network), 2)
            netmask_bin = int(self.ip_to_bin(netmask), 2)
            if dst_ip_bin & netmask_bin == network_bin & netmask_bin:
                return route_desc

    def handle_data(self, message):
        """
        This function handles a data message.

        Parameters:
        message (dict): The data message to handle.
        """
        dst_ip = message["dst"]
        best_route = self.find_best_route(dst_ip)
        if best_route:
            self.forward_data(best_route["received_from"], message)


    def forward_data(self, next_hop, message):
        """
        This function forwards a data packet to the next hop towards its destination.

        Parameters:
        next_hop (str): The next hop for the data packet.
        message (dict): The data packet to forward.
        """
        if next_hop in self.sockets:
            self.send(next_hop, json.dumps(message))
            print(f"Forwarded data packet to {next_hop} for destination {message['dst']}")
        else:
            print(f"Next hop {next_hop} not found in sockets. Cannot forward packet.")


if __name__ == "__main__":
    """Runs the router, given in the starter code"""
    parser = argparse.ArgumentParser(description='Route packets between networks')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', nargs='+', help="Connections in the format port-neighbor-relation")
    args = parser.parse_args()

    router = Router(args.asn, args.connections)
    router.run()